{"pages":[{"title":"Tags","permalink":"https://asadahimeka.github.io/noto/tags/index.html","text":""}],"posts":[{"title":"koa return not found","permalink":"https://asadahimeka.github.io/noto/2018/04/07/koa-return-not-found/","text":"koa returning ‘Not Found’最近在看koa，用koa+mysql搭了个简单demo环境后准备试一下，然后就一直返回Not Found，把数据库相关操作注释掉之后又好了，最后发现原因是logger中间件里的next()前没加return 。。。[喷水] Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const Koa = require('koa');const route = require('koa-route');const cors = require('koa2-cors');const knex = require('knex');const app = new Koa();const mysql = knex(&#123; client: 'mysql', connection: &#123; host: 'localhost', user: 'root', password: '***', database: 'test' &#125;, debug: true, pool: &#123; min: 0, max: 7 &#125;, acquireConnectionTimeout: 10000, migrations: &#123; tableName: 'migrations' &#125;&#125;);const getCodeById = id =&gt; mysql.select().table('test').where('a_tid', id);const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;new Date().toLocaleString()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); return next(); // **前边要加return**&#125;const test = async ctx =&gt; &#123; let res = &#123;&#125;; try &#123; res.data = await getCodeById(1); res.status = 1; res.msg = 'SUCCESS'; &#125; catch (error) &#123; console.log('error: ', error); res.data = []; res.status = 0; res.msg = 'FAIL'; &#125; ctx.response.body = res;&#125;;app.use(cors());app.use(logger);app.use(route.get('/test', test));app.listen(3000); 后来发现已经有现成的koa-logger了[允悲]wwww Answers from stackoverflow It seems that if you want to use a common function as middleware, you have to return the next function. Why common function as middlerware have to return the next function I think it’s because you have to return a promise from your middleware to work with other middlewares. The next return a promise, as you return it, you return a promise. See this issue for more discussions github.com/koajs/koa/issues/997. See more：nodejs(koa):Can’t set headers after they are sent koa2+koa-router+mysql keep returning ‘Not Found’"},{"title":"利用Settings Sync插件同步VS Code设置","permalink":"https://asadahimeka.github.io/noto/2018/03/04/settings-sync-how/","text":"早就听说这个插件了，今天用了一下，确实挺方便的。通过把配置文件创建为Gist上来实现了VS Code设置的同步，下次换电脑或重装时就很便利了。在插件商店搜索Settings Sync然后安装，重载窗口，打开命令面板，输入sync即可查看所有相关命令。 可以同步的设置1234561. VSCode 配置文件2. 键盘绑定文件3. 启动文件4. 代码片段（Snippets）5. 插件6. 工作区 快捷键121. 上传配置: Shift + Alt + U2. 下载配置 : Shift + Alt + D 如何从GitHub获取 Personal Access Token这个插件需要你GitHub账户的Personal Access Token. 可以很简单的按照如下步骤创建一个. 确保在scope里添加了Gist. 到 Settings / Developer settings / Personal access tokens 来生成新的Token 从Scopes里选择Gist. 得到Access Token. 为了将来的使用，保存好这个Token，因为只会看到一次 (i.e. 从别的机器上传配置). 第一次上传配置按下 Shift + Alt + U 来填入GitHub账号的access token. 按下后会自动打开GitHub设置页, 然后生成一个token来允许插件创建Gist. 在窗口里输入生成的token，接着按下回车. 自动上传配置文件后插件会给出这个Gist的ID.以后需要用这个Gist ID来同步你的配置，所以跟token一样一起保存好以便在其他电脑上同步你的配置. 可以通过这个链接查看是否生成了Gist https://gist.github.com/{你的GitHub用户名}/{Gist的ID} Gist打不开的话可以在hosts里添加 192.30.253.118 gist.github.com hosts更新地址 这里有一个上传命令全过程的gif 下载你的配置按下 Shift + Alt + D 然后会问你要GitHub Gist ID. 在命令面板里输入sync来上传或下载 输入你的GitHub Token. 在窗口中输入你的token然后按下回车 输入你的Gist ID. 需要输入你的Gist ID来下载之前上传过的配置 配置下载完毕. 所有的配置文件都下载下来了 下载配置的全过程gif 重置 Token / Gist Settings 在命令面板里输入sync然后选择Reset Token and Gist Settings 自动下载配置自动下载 默认是关闭的 打开的话要确保已经验证了token以及有可用的Gist 当启动时会自动下载最新的配置文件 通过命令面板里 “Sync : Advance Options &gt; Toggle Auto-Download On Startup” 来打开或关闭 配置发生变化时自动上传自动上传 默认是关闭的 打开的话要确保已经验证了token以及有可用的Gist 当配置改变时会自动上传最新的配置文件 通过命令面板里 “Sync : Advance Options &gt; Toggle Auto-Upload on Setting Change” 来打开或关闭 更多查看原文Readme"},{"title":"Observer Pattern","permalink":"https://asadahimeka.github.io/noto/2017/11/03/observer-pattern/","text":"模式动机 建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。 模式定义 观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。 我们可以使用日常生活中，期刊订阅的例子来形象地解释一下上面的概念。期刊订阅包含两个主要的角色：期刊出版方和订阅者，他们之间的关系如下 期刊出版方 - 负责期刊的出版和发行工作 订阅者 - 只需执行订阅操作，新版的期刊发布后，就会主动收到通知，如果取消订阅，以后就不会再收到通知 Def Observer Pattern: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. Frequency of use: high 5/5 UML 模式分析 观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。 这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。 作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publish-subscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。 在观察者模式中也有两个主要角色：Subject (主题) 和 Observer (观察者)。它们分别对应上边例子中的期刊出版方和订阅者。 模式优缺点观察者模式的优点 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。 观察者模式支持广播通信。 观察者模式符合“开闭原则”的要求。 观察者模式的缺点 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 模式应用(FE)在前端领域，观察者模式被广泛地使用。最常见的例子就是为 DOM 对象添加事件监听，具体示例如下： 1&lt;button id=\"btn\"&gt;确认&lt;/button&gt; 12345function clickHandler(event) &#123; console.log('用户已点击确认按钮!');&#125;document.getElementById(\"btn\").addEventListener('click', clickHandler); 上面代码中，我们通过 addEventListener API 监听 button 对象上的点击事件，当用户点击按钮时，会自动执行我们的 clickHandler 函数。 模式例子e.g 1 Subject 类定义：123456789101112131415161718class Subject &#123; constructor() &#123; this.observerCollection = []; &#125; registerObserver(observer) &#123; this.observerCollection.push(observer); &#125; unregisterObserver(observer) &#123; let index = this.observerCollection.indexOf(observer); if(index &gt;= 0) this.observerCollection.splice(index, 1); &#125; notifyObservers() &#123; this.observerCollection.forEach((observer)=&gt;observer.notify()); &#125;&#125; Observer 类定义：12345678910class Observer &#123; constructor(name) &#123; this.name = name; &#125; notify() &#123; console.log(`$&#123;this.name&#125; has been notified.`); &#125;&#125; Client12345678910111213let subject = new Subject(); // 创建主题对象let observer1 = new Observer('semlinker'); // 创建观察者A - 'semlinker'let observer2 = new Observer('lolo'); // 创建观察者B - 'lolo'subject.registerObserver(observer1); // 注册观察者Asubject.registerObserver(observer2); // 注册观察者Bsubject.notifyObservers(); // 通知观察者subject.unregisterObserver(observer1); // 移除观察者Asubject.notifyObservers(); // 验证是否成功移除 以上代码成功运行后控制台的输出结果：123semlinker has been notified. # 输出一次lolo has been notified. # 输出两次lolo has been notified. e.g 2 猫、狗与老鼠 假设猫是老鼠和狗的观察目标，老鼠和狗是观察者，猫叫老鼠跑，狗也跟着叫，使用观察者模式描述该过程。 UML Subject12345678910111213141516abstract class MySubject &#123; protected observerCollection: Array&lt;any&gt;;//存放觀察者 constructor() &#123; this.observerCollection = []; &#125; //注册方法 public attach(observer: MyObserver): void &#123; this.observerCollection.push(observer); &#125; //注销方法 public detach(observer: MyObserver): void &#123; let index = this.observerCollection.indexOf(observer); if (index &gt;= 0) this.observerCollection.splice(index, 1); &#125; public abstract cry(): void;//抽象通知方法&#125; Observer123interface MyObserver &#123; response(): void; //抽象响应方法&#125; Cat12345678class Cat extends MySubject &#123; public cry(): void &#123; console.log(\"------\"); console.log(\"猫叫！\"); console.log(\"------\"); this.observerCollection.forEach((obs: MyObserver) =&gt; obs.response()); &#125;&#125; Dog12345class Dog implements MyObserver &#123; public response(): void &#123; console.log(\"狗跟着叫！\"); &#125;&#125; Mouse123456789class Mouse implements MyObserver &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125; public response(): void &#123; console.log(`老鼠$&#123;this.name&#125;努力逃跑！`); &#125;&#125; Pig12345class Pig implements MyObserver &#123; public response(): void &#123; console.log(\"猪没有反应！\"); &#125;&#125; client1234567891011121314151617let cat = new Cat();let mouse1 = new Mouse('m1');let mouse2 = new Mouse('m2');let dog = new Dog();cat.attach(mouse1);cat.attach(mouse2);cat.attach(dog);let pig = new Pig();cat.attach(pig);cat.cry();cat.detach(mouse2);cat.cry(); 控制台输出12345678910111213------猫叫！------老鼠m1努力逃跑！老鼠m2努力逃跑！狗跟着叫！猪没有反应！------猫叫！------老鼠m1努力逃跑！狗跟着叫！猪没有反应！ Observable(RxJS)RxJS 是基于观察者模式和迭代器模式以函数式编程思维来实现的。RxJS 中含有两个基本概念：Observables 与 Observer。Observables 作为被观察者，是一个值或事件的流集合；而 Observer 则作为观察者，根据 Observables 进行处理。 Observables 与 Observer 之间的订阅发布关系(观察者模式) 如下： 订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable。 发布：Observable 通过回调 next 方法向 Observer 发布事件。 Observer (观察者) 是一个包含三个方法的对象，每当 Observable 触发事件时，便会自动调用观察者的对应方法。Observer 接口定义: 123456interface Observer&lt;T&gt; &#123; closed?: boolean; // 标识是否已经取消对Observable对象的订阅 next: (value: T) =&gt; void; error: (err: any) =&gt; void; complete: () =&gt; void;&#125; Observer 中的三个方法的作用： next - 每当 Observable 发送新值的时候，next 方法会被调用 error - 当 Observable 内发生错误时，error 方法就会被调用 complete - 当 Observable 数据终止后，complete 方法会被调用。在调用 complete 方法之后，next 方法就不会再次被调用 complete 方法执行后，next 就会失效，所以不会输出 not work。 另外观察者可以不用同时包含 next、complete、error 三种方法，它可以只包含一个 next 方法。 可以在调用 Observable 对象的 subscribe 方法时，依次传入 next、error、complete 三个函数，来创建观察者： 12345observable.subscribe( value =&gt; &#123; console.log(value); &#125;, error =&gt; &#123; console.log('Error: ', error); &#125;, () =&gt; &#123; console.log('complete'); &#125;); Angular中接收URL查询参数 1234567891011121314151617181920212223class ComComponent implements OnInit, OnDestroy &#123; private sub : Subscription; constructor( private activatedRoute: ActivatedRoute, ) &#123; &#125; ngOnInit() &#123; //监听变化 this.sub = this.activatedRoute.queryParamMap .subscribe(p =&gt; &#123; console.log(p.get('url')) &#125;) //只用一次的话用快照 console.log(this.route.snapshot.queryParamMap.get('url')); &#125; ngOnDestroy()&#123; this.sub.unsubscribe(); //销毁之后要取消订阅防止内存泄露 //不过ActivatedRoute可以不需要unsubscribe，ng会智能处理 &#125;&#125; 推数据与拉数据Pull 和 Push 是数据生产者和数据的消费者两种不同的交流方式。 什么是Pull? 在 “拉” 体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。 每一个 JavaScript 函数都是一个 “拉” 体系，函数是数据的生产者，调用函数的代码通过 ‘’拉出” 一个单一的返回值来消费该数据。 12const add = (a, b) =&gt; a + b;let sum = add(3, 4); ES6介绍了 iterator迭代器 和 Generator生成器 — 另一种 “拉” 体系，调用 iterator.next() 的代码是消费者，可从中拉取多个值。 什么是Push? 在 “推” 体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。 Promise(承诺) 是当今 JS 中最常见的 “推” 体系，一个Promise (数据的生产者)发送一个 resolved value (成功状态的值)来执行一个回调(数据消费者)，但是不同于函数的地方的是：Promise 决定着何时数据才被推送至这个回调函数。 RxJS 引入了 Observables (可观察对象)，一个全新的 “推” 体系。一个可观察对象是一个产生多值的生产者，当产生新数据的时候，会主动 “推送给” Observer (观察者)。 Promise 返回单个值 不可取消的 Observable 随着时间的推移发出多个值 可以取消的 支持 map、filter、reduce 等操作符 延迟执行，当订阅的时候才会开始执行 REFObserver Pattern 课件 - 刘伟(CSU) Observable 详解"},{"title":"Hello World","permalink":"https://asadahimeka.github.io/noto/2017/11/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]}